import os
import unittest
import shutil
from tensorguard.tgsp.service import TGSPService
from tensorguard.tgsp import container, manifest, spec, crypto
import zipfile

class SecurityPenTest(unittest.TestCase):
    def setUp(self):
        self.workdir = "pentest_workdir"
        os.makedirs(self.workdir, exist_ok=True)
        self.out_dir = os.path.join(self.workdir, "extracted")
        os.makedirs(self.out_dir, exist_ok=True)

    def tearDown(self):
        shutil.rmtree(self.workdir)

    def test_zip_slip_prevention(self):
        """Test that malicious filenames in TGSP manifest are blocked during decryption."""
        # Manually create a malicious ZIP
        malicious_tgsp = os.path.join(self.workdir, "malicious.tgsp")
        
        # 1. Create a dummy package structure
        producer_key = os.path.join(self.workdir, "prod.priv")
        with open(producer_key, "wb") as f: f.write(os.urandom(32))
        
        recipient_pub = os.path.join(self.workdir, "rec.pub")
        recipient_priv = os.path.join(self.workdir, "rec.priv")
        rk = crypto.x25519.X25519PrivateKey.generate()
        with open(recipient_priv, "wb") as f: f.write(rk.private_bytes_raw())
        with open(recipient_pub, "wb") as f: f.write(rk.public_key().public_bytes_raw())

        # We'll use the service but then tamper with the manifest
        payload_file = os.path.join(self.workdir, "innocent.txt")
        with open(payload_file, "wb") as f: f.write(b"Innocent content")
        
        TGSPService.create_package(
            malicious_tgsp,
            signing_key_path=producer_key,
            payloads=[f"p1:weights:{payload_file}"],
            recipients=[f"user1:{recipient_pub}"]
        )
        
        # 2. Tamper with the manifest inside the ZIP to add a Zip-Slip path
        with container.TGSPContainer(malicious_tgsp, 'r') as z:
            m_bytes = z.read_file(spec.MANIFEST_PATH)
            m = manifest.PackageManifest.from_cbor(m_bytes)
            
        # Change filename to something malicious
        m.payloads[0].filename = "../../evil.txt"
        m_bytes_evil = m.to_canonical_cbor()
        
        # Re-write the ZIP with evil manifest
        temp_zip = malicious_tgsp + ".tmp"
        with zipfile.ZipFile(malicious_tgsp, 'r') as zin:
            with zipfile.ZipFile(temp_zip, 'w') as zout:
                for item in zin.infolist():
                    if item.filename == spec.MANIFEST_PATH:
                        zout.writestr(spec.MANIFEST_PATH, m_bytes_evil)
                    else:
                        zout.writestr(item, zin.read(item.filename))
        
        os.remove(malicious_tgsp)
        os.rename(temp_zip, malicious_tgsp)
        
        # 3. Try to decrypt - should fail!
        with self.assertRaises(ValueError) as cm:
            TGSPService.decrypt_package(malicious_tgsp, "user1", recipient_priv, self.out_dir)
        
        self.assertIn("Malicious filename", str(cm.exception))

    def test_unregistered_file_detection(self):
        """Test that extra files in the TGSP container trigger verification failure."""
        safe_tgsp = os.path.join(self.workdir, "safe.tgsp")
        producer_key = os.path.join(self.workdir, "prod_verify.priv")
        with open(producer_key, "wb") as f: f.write(os.urandom(32))
        
        TGSPService.create_package(safe_tgsp, signing_key_path=producer_key)
        
        # Verify OK
        ok, msg = TGSPService.verify_package(safe_tgsp)
        self.assertTrue(ok, f"Should be OK: {msg}")
        
        # Tamper: add extra file
        temp_zip = safe_tgsp + ".tmp"
        with zipfile.ZipFile(safe_tgsp, 'r') as zin:
            with zipfile.ZipFile(temp_zip, 'w') as zout:
                for item in zin.infolist():
                    zout.writestr(item, zin.read(item.filename))
                zout.writestr("GHOST_FILE.txt", b"I am not in the manifest")
        
        os.remove(safe_tgsp)
        os.rename(temp_zip, safe_tgsp)
        
        # Verify should FAIL
        ok, msg = TGSPService.verify_package(safe_tgsp)
        self.assertFalse(ok)
        self.assertIn("Unregistered file", msg)

if __name__ == "__main__":
    unittest.main()
